=>PYTHONTEX#CC:py:begin#none#none#0#code####functions.py#1#
import os, sys

import matplotlib.pyplot as plt
from pylab import gcf
from lib import boilerplate

# Set the prefix used for figure labels
fig_label_prefix = 'fig'
# Track figure numbers to create unique auto-generated names
fig_count = 0

def pytex_printonly(script, data=''):
	import sys
	try:
		from StringIO import StringIO
	except ImportError:
		from io import StringIO
	import contextlib

	if data:
		pytex.add_dependencies(data)

	@contextlib.contextmanager
	def stdoutIO(stdout=None):
		old = sys.stdout
		if stdout is None:
			stdout = StringIO()
		sys.stdout = stdout
		yield stdout
		sys.stdout = old

	with stdoutIO() as s:
		exec(open(script).read(), locals())

	return s.getvalue()

def pytex_tab(script,
	caption='',
	label='',
	options_post='',
	options_pre='',
	data='',
	):
	"""
	Print a LaTeX formatted table (including outer table environment and additional options), based on a script which returns an inner tabular environment and table structure.
	Such scripts are best created using Pandas' `pd.to_latex()` function.
	"""
	pytex.add_dependencies(script)
	import sys
	try:
		from StringIO import StringIO
	except ImportError:
		from io import StringIO
	import contextlib

	if data:
		pytex.add_dependencies(data)

	@contextlib.contextmanager
	def stdoutIO(stdout=None):
		old = sys.stdout
		if stdout is None:
			stdout = StringIO()
		sys.stdout = stdout
		yield stdout
		sys.stdout = old

	with stdoutIO() as s:
		exec(open(script).read(), locals())

	tab = latex_table(s.getvalue(),
		caption=caption,
		label=label,
		options_post=options_post,
		options_pre=options_pre,
		)
	return tab

def pytex_subfigs(scripts,
	caption='',
	label='',
	placement='[h]',
	options_pre='',
	options_post='',
	data=[],
	figure_format='pgf',
	):
	"""
	Executes a series of Python scripts, grabbing the figures individually, and placing them as subfigures in a figure environment
	"""
	pytex.add_dependencies(*data)
	subfigs = '\\begin{{figure*}}{}\n'.format(placement)
	if options_pre:
		subfigs += '{}\n'.format(options_pre)
	for script in scripts:
		try:
			script_conf = script['conf']
		except KeyError:
			script_conf=[]
		try:
			script_caption = script['caption']
		except KeyError:
			script_caption=''
		try:
			script_label = script['label']
		except KeyError:
			script_label=''
		try:
			script_options_post = script['options_post']
		except KeyError:
			script_options_post=''
		try:
			script_options_pre = script['options_pre']
		except KeyError:
			script_options_pre=''
		try:
			script_options_pre_caption = script['options_pre_caption']
		except KeyError:
			script_options_pre_caption = ''
		try:
			script_figure_format = script['figure_format']
		except KeyError:
			script_figure_format = figure_format
		subfig = pytex_fig(script['script'],
			conf=script_conf,
			caption=script_caption,
			label=script_label,
			environment='subfigure',
			options_post=script_options_post,
			options_pre=script_options_pre,
			options_pre_caption=script_options_pre_caption,
			figure_format=script_figure_format,
			)
		subfigs += subfig
		subfigs += '\\hfill\n'
	if caption:
		subfigs += '\\caption{{{}}}\n'.format(caption)
	if label:
		subfigs += '\\label{{{}}}\n'.format(label)
	if options_post:
		subfigs += '{}\n'.format(options_post)
	subfigs += '\\end{figure*}'
	return subfigs

def pytex_fig(script,
	conf=[],
	caption='',
	label='',
	multicol=False,
	environment='figure',
	options_post='',
	options_pre='[htp]',
	options_pre_caption='',
	data=[],
	figure_format='pgf',
	):
	'''
	Executes a Python script while applying the custom style.

	Notes
	-----
	We go about this in a somewhat roundabout fashion - always applying `DOC_STYLE`, and then additionally applying a context style which may be only `[DOC_STYLE]` in case no other config file is specified.
	This is because scripts need to be executed in a while statement lest rcParams become persistent between figures.
	Conversely, the text engine part of the configuration needs to be applied outside of the context statement, because it will not work inside it.
	'''
	pytex.add_dependencies(script)
	try:
		document_style = DOC_STYLE
	except NameError:
		document_style = ''
	#for some reason this needs to be applied here, in addition to the context application
	#below (where it can be omitted, but is needed to make sure the `figre_styles` variable is populated).
	plt.style.use(document_style)
	try:
		if isinstance(conf, basestring):
			conf = [conf]
	except NameError:
		if isinstance(conf, str):
			conf = [conf]
	figure_styles = [document_style]+conf+data
	pytex.add_dependencies(*figure_styles)
	with plt.style.context(figure_styles):
		exec(open(script).read())
	if multicol:
		environment='figure*'
	fig = latex_figure(save_fig(ext='.{}'.format(figure_format)), environment,
		caption=caption,
		label=label,
		options_post=options_post,
		options_pre=options_pre,
		options_pre_caption=options_pre_caption,
		figure_format=figure_format,
		)
	return fig

def figure_by_path(figure_path,textheight_frac=1,caption=None,label=None):
	latex_code = "\\begin{figure}\n"
	latex_code += "\\centering\\includegraphics[width={textheight_frac}\\textheight]{{{figure_path}}}\n".format(textheight_frac=textheight_frac,figure_path=figure_path)
	latex_code += "\\vspace{-.5em}\n"
	latex_code += "\\caption{{{caption}}}\n".format(caption=caption)
	latex_code += "\\label{{fig:{label}}}\n".format(label=label)
	latex_code += "\\end{figure}\n"
	return latex_code

def save_fig(name='', legend=False, fig=None, ext='.pgf'):
	'''
	Save the current figure (or `fig`) to file using `plt.save_fig()`.
	If called with no arguments, automatically generate a unique filename.
	Return the filename.
	'''
	# Get name (without extension) and extension
	if not name:
		global fig_count
		# Need underscores or other delimiters between `input_*` variables
		# to ensure uniqueness
		name = 'auto_fig_{}-{}'.format(pytex.id, fig_count)
		fig_count += 1
	else:
		if len(name) > 4 and name[:-4] in ['.pdf', '.pgf', '.svg', '.png', '.jpg']:
			name, ext = name.rsplit('.', 1)

	# Get current figure if figure isn't specified
	if not fig:
		fig = gcf()
	fig.savefig(name + ext)
	fig.clear()
	plt.cla()
	plt.clf()
	plt.close()
	plt.close('all')
	return name

def latex_environment(name,
	content='',
	options_post='',
	options_pre='',
	):
	"""
	Simple helper function to write the `\begin...\end` LaTeX block.
	"""
	return '\\begin{%s}%s%s%s\\end{%s}' % (name, options_pre, content, options_post, name)

def latex_table(table,
	caption='',
	label='',
	options_post='',
	options_pre='',
	):
	"""
	Add caption and label to an inner tabular environment and than wrap in the outer LaTeX `'table'` environment.
	"""
	content = table
	caption= "\\caption{%s\\label{%s:%s}}\n" % (caption, "tab", label)
	options_post += caption
	return latex_environment("table",
		content=content,
		options_post=options_post,
		options_pre=options_pre,
		)

def latex_figure(name, environment,
	caption='',
	label='',
	width=1,
	options_post='',
	options_pre_caption='',
	options_pre='[htp]',
	figure_format='pgf',
	):
	"""
	Auto wrap `name` in a LaTeX figure environment.
	Width is a fraction of `\textwidth`.
	"""
	if not name:
		name = save_fig()
	content = '\\centering\n'
	if figure_format == 'pgf':
		content += '\\makeatletter\\let\\input@path\\Ginput@path\\makeatother\n'
		content += '\\input{{{}.{}}}\n'.format(name, figure_format)
	elif figure_format == 'pdf':
		content += '\\includegraphics{{{}}}\n'.format(name)
	if options_pre_caption:
		content+= '{}\n'.format(options_pre_caption)
	if not label:
		label = name
	if caption:
		# `\label` needs to be in `\caption` to avoid issues in some cases
		content += "\\caption{%s\\label{%s:%s}}\n" % (caption, fig_label_prefix, label)
	return latex_environment(environment,
		content=content,
		options_pre=options_pre,
		options_post=options_post,
		)

=>PYTHONTEX#CC:py:end#none#none#0#code####functions.py#297#
=>PYTHONTEX#CC:py:begin#none#none#1#code#####104#
DOC_STYLE = 'article/main.conf'
pytex.add_dependencies(DOC_STYLE,
	'article/3dplot.conf',
	'lib/utils.py',
	'lib/categorical.py',
	'data/volume.csv'
	)
=>PYTHONTEX#py#default#default#0#i####abstract_general.tex#6#
pytex_printonly('scripts/vc_rmser.py')
=>PYTHONTEX#py#default#default#1#i####abstract_general.tex#7#
pytex_printonly('scripts/scf_rmser.py')
=>PYTHONTEX#py#default#default#2#i####evaluation.tex#49#
pytex_subfigs(         [                 {'script':'scripts/vc_violin.py', 'label':'vcv', 'conf':'article/1col.conf', 'options_pre':'{.48\\textwidth} \\vspace{-2em}',                         'options_pre_caption':'\\vspace{-1.5em}',                         'options_post':'\\vspace{1em}',                         'caption':'Comparison across workflows and target templates, considering both BOLD and CBV functional contrasts.'                         ,},                 {'script':'scripts/vcc_violin.py', 'label':'vccv','conf':'article/1col.conf', 'options_pre':'{.48\\textwidth} \\vspace{-2em}',                         'options_pre_caption':'\\vspace{-1.5em}',                         'options_post':'\\vspace{1em}',                         'caption':'Comparison across workflows and functional contrasts, considering only matching template-workflow combinations.'                         ,},                 {'script':'scripts/scf_violin_templates.py', 'label':'scv', 'conf':'article/1col.conf', 'options_pre':'{.48\\textwidth}',                         'options_pre_caption':'\\vspace{-1.5em}\\',                         'options_post':'\\vspace{1em}',                         'caption':'Comparison across workflows and target templates, considering both BOLD and CBV functional contrasts.'                         ,},                 {'script':'scripts/scf_violin_contrasts.py', 'label':'sccv','conf':'article/1col.conf', 'options_pre':'{.48\\textwidth}',                         'options_pre_caption':'\\vspace{-1.5em}\\',                         'options_post':'\\vspace{1em}',                         'caption':'Comparison across workflows and functional contrasts, considering only matching template-workflow combinations.'                         ,},                 {'script':'scripts/ms_violin.py', 'label':'msv', 'conf':'article/1col.conf', 'options_pre':'{.48\\textwidth}',                         'options_pre_caption':'\\vspace{-1.5em}', 			'caption':'Comparison across workflows and target templates, considering both BOLD and CBV functional contrasts.'                         ,},                 {'script':'scripts/msc_violin.py', 'label':'mscv','conf':'article/1col.conf', 'options_pre':'{.48\\textwidth}',                         'options_pre_caption':'\\vspace{-1.5em}',                         'caption':'Comparison across workflows and functional contrasts, considering only matching template-workflow combinations.'                         ,},                 ],         caption='\\textbf{The SAMRI Generic workflow and template optimally and reliably conserve volume and smoothness --- unlike the Legacy workflow and template.}         Plots of three target metrics, with coloured patch widths estimating distribution density, solid lines indicating the sample mean, and dashed lines indicate the inner quartiles.         ',         label='fig:vc',         )
=>PYTHONTEX#py#default#default#3#i####evaluation.tex#57#
boilerplate.fstatistic('Processing', condensed=True)
=>PYTHONTEX#py#default#default#4#i####evaluation.tex#58#
boilerplate.fstatistic('Template', condensed=True)
=>PYTHONTEX#py#default#default#5#i####evaluation.tex#59#
boilerplate.fstatistic('Processing:Template', condensed=True)
=>PYTHONTEX#py#default#default#6#i####evaluation.tex#61#
pytex_printonly('scripts/vc_t.py')
=>PYTHONTEX#py#default#default#7#i####evaluation.tex#63#
pytex_printonly('scripts/vc_rmser.py')
=>PYTHONTEX#py#default#default#8#i####evaluation.tex#66#
boilerplate.factorci('Template[T.Legacy]')
=>PYTHONTEX#py#default#default#9#i####evaluation.tex#68#
boilerplate.factorci('Processing[T.Legacy]')
=>PYTHONTEX#py#default#default#10#i####evaluation.tex#70#
boilerplate.varianceratio(template='Legacy')
=>PYTHONTEX#py#default#default#11#i####evaluation.tex#70#
boilerplate.varianceratio(template='Generic')
=>PYTHONTEX#py#default#default#12#i####evaluation.tex#73#
boilerplate.corecomparison_factorci('Contrast[T.CBV]')
=>PYTHONTEX#py#default#default#13#i####evaluation.tex#75#
boilerplate.corecomparison_factorci('Processing[T.Legacy]:Contrast[T.CBV]')
=>PYTHONTEX#py#default#default#14#i####evaluation.tex#86#
boilerplate.fstatistic('Template', condensed=True, df_path='data/smoothness.csv', dependent_variable='Smoothness Conservation Factor')
=>PYTHONTEX#py#default#default#15#i####evaluation.tex#87#
boilerplate.fstatistic('Processing', condensed=True, df_path='data/smoothness.csv', dependent_variable='Smoothness Conservation Factor')
=>PYTHONTEX#py#default#default#16#i####evaluation.tex#88#
boilerplate.fstatistic('Processing:Template', condensed=True, df_path='data/smoothness.csv', dependent_variable='Smoothness Conservation Factor')
=>PYTHONTEX#py#default#default#17#i####evaluation.tex#90#
pytex_printonly('scripts/scf_t.py')
=>PYTHONTEX#py#default#default#18#i####evaluation.tex#92#
pytex_printonly('scripts/scf_rmser.py')
=>PYTHONTEX#py#default#default#19#i####evaluation.tex#95#
boilerplate.factorci('Template[T.Legacy]', df_path='data/smoothness.csv', dependent_variable='Smoothness Conservation Factor')
=>PYTHONTEX#py#default#default#20#i####evaluation.tex#97#
boilerplate.factorci('Processing[T.Legacy]', df_path='data/smoothness.csv', dependent_variable='Smoothness Conservation Factor')
=>PYTHONTEX#py#default#default#21#i####evaluation.tex#99#
boilerplate.varianceratio(df_path='data/smoothness.csv',dependent_variable='Smoothness Conservation Factor', max_len=3, template='Legacy')
=>PYTHONTEX#py#default#default#22#i####evaluation.tex#99#
boilerplate.varianceratio(df_path='data/smoothness.csv',dependent_variable='Smoothness Conservation Factor', template='Generic', max_len=3)
=>PYTHONTEX#py#default#default#23#i####evaluation.tex#102#
boilerplate.corecomparison_factorci('Contrast[T.CBV]', df_path='data/smoothness.csv', dependent_variable='Smoothness Conservation Factor')
=>PYTHONTEX#py#default#default#24#i####evaluation.tex#104#
boilerplate.corecomparison_factorci('Processing[T.Legacy]:Contrast[T.CBV]', df_path='data/smoothness.csv', dependent_variable='Smoothness Conservation Factor')
=>PYTHONTEX#py#default#default#25#i####evaluation.tex#116#
boilerplate.fstatistic('Processing', dependent_variable='Mean Significance', df_path='data/functional_significance.csv', condensed=True)
=>PYTHONTEX#py#default#default#26#i####evaluation.tex#118#
boilerplate.fstatistic('Template', dependent_variable='Mean Significance', df_path='data/functional_significance.csv', condensed=True)
=>PYTHONTEX#py#default#default#27#i####evaluation.tex#120#
boilerplate.fstatistic('Processing:Template', dependent_variable='Mean Significance', df_path='data/functional_significance.csv', condensed=True)
=>PYTHONTEX#py#default#default#28#i####evaluation.tex#122#
pytex_printonly('scripts/ms_t.py')
=>PYTHONTEX#py#default#default#29#i####evaluation.tex#125#
boilerplate.factorci('Processing[T.Legacy]', df_path='data/functional_significance.csv', dependent_variable='Mean Significance')
=>PYTHONTEX#py#default#default#30#i####evaluation.tex#127#
boilerplate.factorci('Template[T.Legacy]', df_path='data/functional_significance.csv', dependent_variable='Mean Significance')
=>PYTHONTEX#py#default#default#31#i####evaluation.tex#129#
boilerplate.factorci('Processing[T.Legacy]:Template[T.Legacy]', df_path='data/functional_significance.csv', dependent_variable='Mean Significance')
=>PYTHONTEX#py#default#default#32#i####evaluation.tex#132#
boilerplate.varianceratio(df_path='data/functional_significance.csv', template='Legacy', dependent_variable='Mean Significance')
=>PYTHONTEX#py#default#default#33#i####evaluation.tex#134#
boilerplate.varianceratio(df_path='data/functional_significance.csv', template='Generic', dependent_variable='Mean Significance')
=>PYTHONTEX#py#default#default#34#i####evaluation.tex#138#
boilerplate.corecomparison_factorci('Contrast[T.CBV]', df_path='data/functional_significance.csv', dependent_variable='Mean Significance')
=>PYTHONTEX#py#default#default#35#i####evaluation.tex#140#
boilerplate.corecomparison_factorci('Processing[T.Legacy]:Contrast[T.CBV]', df_path='data/functional_significance.csv', dependent_variable='Mean Significance')
=>PYTHONTEX#py#default#default#36#i####evaluation.tex#199#
pytex_subfigs( 	[ 		{'script':'scripts/map_generic_cbv.py', 'label':'mggc', 'conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':'                                 Generic workflow with Generic template CBV map, showing correct slice orientation and coverage correctly bounded to the acquisition area.                                 ' 			,}, 		{'script':'scripts/map_generic_ambmc_cbv.py', 'label':'mglc','conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':'                                 Generic workflow with Legacy template CBV map, showing incorrect slice orientation and coverage correctly bounded to the acquisition area.                                 ' 			,}, 		{'script':'scripts/map_legacy_dsurqec_cbv.py', 'label':'mlgc','conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':'                                 Legacy workflow with Generic template CBV map, showing correct slice orientation and coverage caudally extending beyond the acquisition area.                                 ' 			,}, 		{'script':'scripts/map_legacy_cbv.py', 'label':'mllc','conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':' 				Legacy workflow with Legacy template CBV map, showing incorrect slice orientation and coverage both caudally and rostrally extending beyond acquisition area. 				' 			,}, 		{'script':'scripts/map_generic_bold.py', 'label':'mggb', 'conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':'                                 Generic workflow with Generic template BOLD map, showing correct slice orientation and coverage correctly bounded to the acquisition area.                                 ' 			,}, 		{'script':'scripts/map_generic_ambmc_bold.py', 'label':'mglb','conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':'                                 Generic workflow with Legacy template BOLD map, showing incorrect slice orientation and coverage correctly bounded to the acquisition area.                                 ' 			,}, 		{'script':'scripts/map_legacy_dsurqec_bold.py', 'label':'mlgb','conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':'                                 Legacy workflow with Generic template BOLD map, showing correct slice orientation and coverage caudally extending beyond acquisition area.                                 ' 			,}, 		{'script':'scripts/map_legacy_bold.py', 'label':'mllb','conf':'article/map.conf', 'options_pre':'{.48\\textwidth}', 			'caption':' 				Legacy workflow with Legacy template BOLD map, showing incorrect slice orientation and coverage both caudally and rostrally extending beyond acquisition area. 			        '                         ,}, 		], 	caption='                 \\textbf{Legacy workflow processing leads to a problematic overflow of the statistic maps into adjacent anatomical regions, leaking beyond the acquistion area.}                 SAMRI mitigates this effect as illustrated by multiplanar depictions of second-level omnibus statistic maps separately evaluating CBV and BOLD scans, and thresholded at $\mathrm{|t|\geq2}$.                 The acquisition area is bracketed in pink, and in comparing it to statistic coverage it is important to note that the latter is always underestimated, as the omnibus statistic contrast is only defined for voxels captured in \\textit{every} evaluated scan.                 ', 	label='fig:m',)
=>PYTHONTEX#py#default#default#37#i####evaluation.tex#212#
pytex_fig('scripts/variance_catplot.py',         conf='article/varplot.conf',         label='var',         caption='                 \\textbf{The SAMRI Generic workflow conserves subject-wise variability and minimizes trial-to-trial variability compared to the Legacy workflow.}                 Swarmplots illustrate similarity metric scores of preprocessed images with respect to the corresponding workflow template, plotted across subjects (separated into x-axis bins) and sessions (individual points in each x-axis bin), for the CBV contrast.                 ',         multicol=True,         )
=>PYTHONTEX#py#default#default#38#i####evaluation.tex#227#
boilerplate.variance_test('C(Subject)','Legacy','CC', condensed=True)
=>PYTHONTEX#py#default#default#39#i####evaluation.tex#227#
boilerplate.variance_test('C(Session)','Legacy','CC', condensed=True)
=>PYTHONTEX#py#default#default#40#i####evaluation.tex#228#
boilerplate.variance_test('C(Subject)','Legacy','GC', condensed=True)
=>PYTHONTEX#py#default#default#41#i####evaluation.tex#228#
boilerplate.variance_test('C(Session)','Legacy','GC', condensed=True)
=>PYTHONTEX#py#default#default#42#i####evaluation.tex#229#
boilerplate.variance_test('C(Subject)','Legacy','MI', condensed=True)
=>PYTHONTEX#py#default#default#43#i####evaluation.tex#229#
boilerplate.variance_test('C(Session)','Legacy','MI', condensed=True)
=>PYTHONTEX#py#default#default#44#i####evaluation.tex#233#
boilerplate.variance_test('C(Subject)','Generic','CC', condensed=True)
=>PYTHONTEX#py#default#default#45#i####evaluation.tex#233#
boilerplate.variance_test('C(Session)','Generic','CC', condensed=True)
=>PYTHONTEX#py#default#default#46#i####evaluation.tex#234#
boilerplate.variance_test('C(Subject)','Generic','GC', condensed=True)
=>PYTHONTEX#py#default#default#47#i####evaluation.tex#234#
boilerplate.variance_test('C(Session)','Generic','GC', condensed=True)
=>PYTHONTEX#py#default#default#48#i####evaluation.tex#235#
boilerplate.variance_test('C(Subject)','Generic','MI', condensed=True)
=>PYTHONTEX#py#default#default#49#i####evaluation.tex#235#
boilerplate.variance_test('C(Session)','Generic','MI', condensed=True)
=>PYTHONTEX#py#default#default#50#i####supplementary.tex#120#
pytex_tab('scripts/stim_table.py',                 label='stim',                 caption='Stimulation protocol, as delivered during functional scans.                         Stimulus event spacing and parameters are constant across scans, but the exact onset time is variable in the \SI{10}{\second} magnitude range due to scanner adjustment time variability.',                 options_pre='[htp] \\scriptsize \\centering \\resizebox{\\columnwidth}{!}{',                 data='data/JogB.tsv',                 options_post='}',                 )
=>PYTHONTEX:SETTINGS#
version=0.16
outputdir=pythontex-files-article_general
workingdir=.
workingdirset=false
gobble=auto
rerun=default
hashdependencies=default
makestderr=false
stderrfilename=full
keeptemps=none
pyfuture=all
pyconfuture=none
pygments=true
pygglobal=:GLOBAL||
fvextfile=-1
pyconbanner=none
pyconfilename=stdin
depythontex=false
pygfamily=py|python|
pygfamily=pycon|pycon|
pygfamily=sympy|python|
pygfamily=sympycon|pycon|
pygfamily=pylab|python|
pygfamily=pylabcon|pycon|
