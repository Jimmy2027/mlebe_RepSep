\section{Methods}
It is of foremost importance that the complexity of MRI processing interfaces is manageable to their prospective users, such as biologists with only cursory programming experience.
One should, however, also consider that the pipeline execution transparency and reproducibility (which are what make it suitable for scientific data analysis to begin with) are not compromised for trivial features which purportedly aid convenience. 
We thus follow  a set of design guidelines, stating that:
each pipeline is represented by a high-level function, whose parameters correspond to operator-understandable concepts (i.e. describe the operations performed, rather than the computational manner in which they are performed); 
pipeline functions are highly parameterized (so that users can change their function to a significant extent without needing to edit the constituent code) but include sane defaults;
and graphical or interactive interfaces are wholly avoided (as they impede reproducibility, encumber the dependency graph, and reduce the sustainability of the project).

\begin{figure*}[h]
	\begin{subfigure}{.67\textwidth}
		\centering
		\includedot[width=\textwidth]{data/generic}
		\vspace{.55em}
		\caption{1a}
		\label{fig:sfig1}
	\end{subfigure}%
	\begin{subfigure}{.33\textwidth}
		\centering
		\includedot[width=\textwidth]{data/legacy}
		\caption{1b}
		\label{fig:sfig2}
	\end{subfigure}
	\caption{LALALALLALALALnvoewfjiweof eowijfoiwe foiewfwi}
	\label{fig:wfs}
\end{figure*}

The language of choice for the pipelining interfaces is Python, owing to its Free and Open Source (FOSS) nature, readability, wealth of available libraries, ease of package management, and its large and dynamic developer community.
While pipeline functions are written in Python, we also provide automatically generated Command Line Interfaces (CLIs), for use directly with Bash.
These autogenerated CLIs ensure that features become available in Bash and Python synchronoulsy, and pipelines behave identically regardless of the language in which they are invoked.

\subsection{Technologies}

Internally, the workflow functions make use of the Nipype \cite{nipype} package, which provides high-level management and execution features.
Via this package, functions provided by any other package can be encapsulated in a node (complete with error reporting and isolated re-execution support) and integrated into the directed workflow graph.
Paralellization can also be managed via a number of execution plugins, allowing excelelnt scalability.
Most importantly, Nipype can generate graph descriptor language (DOT) as well as visual representations (see \cref{fig:wfs})

Inside the framework constructed with Nipype we utilize functions from the FSL and AFNI packages.

acyclic graph construction and reporting features, as well as jobs and resources management, and error reporting functions for the pipeline execution --- features which make it excellently suited to construct. 

